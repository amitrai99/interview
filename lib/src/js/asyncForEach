// Write an async forEach function with and without promises.
// array.forEach does not support async functions out of box just like native for loop doesn't

// Problem start point. If you run this code it will print undefined.
function printMessage(i) {
  setTimeout((i) => { console.log(i) }, 1000);
}

const arr = [1, 2, 3, 4, 5, 6, 7];

arr.forEach(async (i) => {
  await printMessage(i);
});

// There are multiple ways to do this
// 1. With promises see below. We can also Write an async forEach function with and without promises.

// setup array
const nums = [1, 2, 3, 4, 5, 6];

// an async function that needs to be called
function callMe(i) {
	return new Promise((resolve, reject) => {
    // Here we want to resolve odd values and reject the even numbers
    if (i%2) {
    setTimeout(() => reject(i), 1000);
    } else {
      setTimeout(() => resolve(i), 1000);
    }
  });
}

// Our main asyncForEach function that wraps the native array.forEach
function asyncForEach(arr, func) {
    arr.forEach(
      async (i) => {
        await callMe(i); console.log(i);
      }
    );
}

asyncForEach(nums);

//Reading in sequence
// If you want to read the files in sequence, you cannot use forEach indeed. Just use a modern for â€¦ of loop instead, in which await will work as expected:

async function printFiles () {
  const files = await getFilePaths();

  for (const file of files) {
    const contents = await fs.readFile(file, 'utf8');
    console.log(contents);
  }
}

// Reading in parallel
// If you want to read the files in parallel, you cannot use forEach indeed. Each of the async callback function calls does return a promise, but you're throwing them away instead of awaiting them. Just use map instead, and you can await the array of promises that you'll get with Promise.all:

async function printFiles () {
  const files = await getFilePaths();

  await Promise.all(files.map(async (file) => {
    const contents = await fs.readFile(file, 'utf8')
    console.log(contents)
  }));
}
